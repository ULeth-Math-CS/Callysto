<!DOCTYPE html>
<html>
<head>
  <title>Permutations Notebook</title>
  <script type = "text/javascript" src = "https://d3js.org/d3.v4.min.js"></script>
  <style>
    h1 {
      text-align: center;
    }
    body {
      background-color: #0099cc;
    }

    hr {
      border-color: #007399;
    }

    #slider-output {
        display: inline-block;
      }

      #perm-range-container {
          width: 50%
      }

      #slider-output-container {
          padding-top: 10px;
      }

      .slider {
          display: inline-block;
          -webkit-appearance: none;  /* Override default CSS styles */
          appearance: none;
          width: 100%; /* Full-width */
          height: 15px; /* Specified height */
          background: #d3d3d3; /* Grey background */
          outline: none; /* Remove outline */
          opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
          -webkit-transition: .2s; /* 0.2 seconds transition on hover */
          transition: opacity .2
          border-radius: 5px;
      }

      .slider::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 25px;
          height: 25px;
          border-radius: 50%;
          background: #4CAF50;
          cursor: pointer;
      }

      .slider::-moz-range-thumb {
          width: 25px;
          height: 25px;
          border-radius: 50%;
          background: #4CAF50;
          cursor: pointer;
      }
  </style>
</head>
<body>
  <h1>Permutations</h1>
  <hr>
  <div id="svg-container5">
  </div>
  <div id="perm-range-container">
      <input class="slider" id="perm-range-slider" type="range" min="2" max="10" value="5">
  </div>
  <div id="slider-output-container">
      <p>Number of circles: <span id="slider-output"></span></p>
  </div>
  <script>
    var colors = ["red", "green", "blue", "gray", "yellow", "teal", "aqua", "purple", "silver", "lime"];
    var animationTime = 5000;
    var t = d3.transition().duration(animationTime);
    var drag_handler = d3.drag()
      .on("drag", function(d) {
            d3.select(this)
              .attr("cx", d3.event.x  )
              .attr("cy", d3.event.y  );
      })
      .on("start", function(d) {
        startX = d3.event.x;
        startY = d3.event.y;
        draggedCircleIndex = 0;
        for(var i = 0; i < drivingData.length; ++i) {
          if(startX == drivingData[i].x) {
            draggedCircleIndex = i;
            break;
          }
        }
      })
      .on("end", function(d) {
          var circle = d3.select(this);
          var endX = Number(circle.attr("cx"));

          var inserted = false;
          if(Math.abs(startX-endX) < distanceBetweenCircles) {
            d3.select(this).transition(t)
              .attr("cx", function() {
                return drivingData[draggedCircleIndex].x;
              })
              .attr("cy", circleLineHeight);
          }

          else if(startX > endX) {
            var left = true;
            var index = draggedCircleIndex - 1;
            while(index >= 0 && !inserted) {
              if(endX < drivingData[index].x && (drivingData[index].x - endX) < distanceBetweenCircles) {
                // transition to the right
                svg.selectAll("circle")
                  .filter(function(d, i) {
                    return i >= index && i < draggedCircleIndex;
                  })
                  .transition()
                      .attr("cx", function() {
                        return Number(d3.select(this).attr("cx")) + distanceBetweenCircles;
                      });

                // d3.select(this).transition(t)
                //   .attr("cx", function() {
                //     return drivingData[index].x;
                //   })
                //   .attr("cy", circleLineHeight)
                //   .on("end", rearrangeData(index, draggedCircleIndex, 0));

                inserted = true;
              }

              --index;
            }
          }

          else if(endX > startX) {
              var left = false;
              var index = 0;
              while(!inserted && index < drivingData.length) {
                  if(endX > drivingData[index].x && Math.abs(drivingData[index].x - endX) < distanceBetweenCircles) {
                    console.log("Going right!");
                    svg.selectAll("circle")
                      .filter(function(d, i) {
                        return i <= index && i > draggedCircleIndex;
                      })
                      .transition()
                          .attr("cx", function() {
                            return Number(d3.select(this).attr("cx")) - distanceBetweenCircles;
                          });

                      d3.select(this).transition()
                        .attr("cx", function() {
                          return drivingData[index].x;
                        })
                        .attr("cy", function() {
                          return drivingData[index].y;
                        }).call(endall)

                      setTimeout(rearrangeData(index, draggedCircleIndex, 1), animationTime+500);
                      inserted = true;
                  }

                  ++index;
              }
          }
      })
    var radius = 20;
    var distanceBetweenCircles = 50;
    var startingXNode = 40;
    var circleLineHeight = 150;

    var slider = document.getElementById("perm-range-slider");
    var output = document.getElementById("slider-output");
    var drivingData = [];
    for(var i = 0; i < slider.value; ++i) {
      var data = {x:(i*distanceBetweenCircles)+startingXNode, color:colors[i] };
      drivingData.push(data);
    }

    output.innerHTML = slider.value; // Display the default slider value
    // Create svg
    var svg = d3.select("#svg-container5")
      .append("svg")
        .attr("width", "100%")
        .attr("height", 300)
      .append("g");

    // Create original circles
    createCircles(drivingData);

    // Variables for drag_handler
    var startX = 0;
    var startY = 0;
    var draggedCircleIndex = 0;

    // Update the current slider value (each time you drag the slider handle)
    slider.oninput = function() {
        output.innerHTML = this.value;
        createCircles(this.value);
    }


    function createCircles(d) {
        var circles = svg.selectAll("circle")
          .data(d)
            .enter()
              .append("circle")
                .attr("cx", function(d) {
                  return d.x;
                })
                .attr("cy", circleLineHeight)
                .attr("r", radius)
                .attr("fill", function(d) {
                  return d.color;
                });

        drag_handler(circles);
    }



    function updateCircles(d) {
      var circles = svg.selectAll("circle")
        .data(d);

      console.log(circles.data());
      circles.attr("cx", function(d) { return d.x; });
      circles.attr("cy", circleLineHeight);
      circles.attr("fill", function(d) { return d.color; });
    }

    function addCircle() {

    }

    function removeCircle() {

    }

    function rearrangeData(startingIndex, insertedIndex, direction) {
      console.log("Rearranging Data!");
      if(direction) {
        var originalStart = drivingData[startingIndex];
        for(var i = startingIndex; i > insertedIndex; --i) {
          drivingData[i] = drivingData[i - 1];
          drivingData[i].x += distanceBetweenCircles;
        }

        drivingData[insertedIndex] = originalStart;
        drivingData[insertedIndex].x -= distanceBetweenCircles * (startingIndex - insertedIndex);
      }

      else {
        var originalStart = drivingData[startingIndex];
        for(var i = startingIndex; i < insertedIndex; ++i) {
            drivingData[i] = drivingData[i+1];
            drivingData[i].x -= distanceBetweenCircles;
        }

        drivingData[insertedIndex] = originalStart;
        drivingData[insertedIndex].x += distanceBetweenCircles * (insertedIndex - startingIndex);

      }

      updateCircles(drivingData);
    }

    function endall(transition, callback) {
      if (typeof callback !== "function") throw new Error("Wrong callback in endall");
      if (transition.size() === 0) { callback() }
      var n = 0;
      transition
        .each(function() { ++n; })
        .each("end", function() { if (!--n) callback.apply(this, arguments); });
    }

    function test() {
      console.log("Hi!");
    }
  </script>
</body>
</html>
